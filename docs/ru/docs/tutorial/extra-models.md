# Дополнительные модели

Продолжая с предыдущим примером, будет обычным явлением иметь более одной связанной модели.

Это особенно применимо в случае пользовательских моделей, потому что:

* **Модель для ввода** должна иметь возможность включать пароль.
* **Модель для вывода** не должна содержать пароль.
* **Модель для базы данных** вероятно должна включать хэшированный пароль.

/// danger | Опасность

Никогда не храните пароли пользователей в открытом виде. Всегда храните "безопасный хэш", который вы затем сможете проверить.

Если вы не знаете, вы можете узнать, что такое "хэш пароля" в [главе по безопасности](security/simple-oauth2.md#password-hashing){.internal-link target=_blank}.

///

## Множественные модели

Вот общая идея о том, как могут выглядеть модели с их полями пароля и где они используются:

{* ../../docs_src/extra_models/tutorial001_py310.py hl[7,9,14,20,22,27:28,31:33,38:39] *}


/// info | Информация

В Pydantic v1 метод назывался `.dict()`, в Pydantic v2 он был устаревшим (но всё ещё поддерживается) и переименован в `.model_dump()`.

В примерах здесь используется `.dict()` для совместимости с Pydantic v1, но если вы можете использовать Pydantic v2, следует использовать `.model_dump()`.

///

### Про `**user_in.dict()`

#### `.dict()` из Pydantic

`user_in` — это модель Pydantic класса `UserIn`.

У моделей Pydantic есть метод `.dict()`, который возвращает `dict` с данными модели.

Итак, если мы создадим объект Pydantic `user_in` так:

```Python
user_in = UserIn(username="john", password="secret", email="john.doe@example.com")
```

а затем вызовем:

```Python
user_dict = user_in.dict()
```

теперь у нас есть `dict` с данными в переменной `user_dict` (это `dict` вместо объекта Pydantic- модели).

И если мы вызовем:

```Python
print(user_dict)
```

мы получим Python `dict` с:

```Python
{
    'username': 'john',
    'password': 'secret',
    'email': 'john.doe@example.com',
    'full_name': None,
}
```

#### Распаковка `dict`

Если мы возьмём `dict` вроде `user_dict` и передадим его в функцию (или класс) с помощью `**user_dict`, Python "распакует" его. Он передаст ключи и значения `user_dict` напрямую как аргументы ключ-значение.

Поэтому, продолжая с `user_dict`, написание:

```Python
UserInDB(**user_dict)
```

будет эквивалентно:

```Python
UserInDB(
    username="john",
    password="secret",
    email="john.doe@example.com",
    full_name=None,
)
```

Или более точно, используя `user_dict` напрямую, с любым потенциальным содержимым:

```Python
UserInDB(
    username = user_dict["username"],
    password = user_dict["password"],
    email = user_dict["email"],
    full_name = user_dict["full_name"],
)
```

#### Pydantic-модель из содержимого другой модели

Как в примере выше мы получили `user_dict` из `user_in.dict()`, этот код:

```Python
user_dict = user_in.dict()
UserInDB(**user_dict)
```

будет эквивалентен:

```Python
UserInDB(**user_in.dict())
```

...потому что `user_in.dict()` — это `dict`, и затем мы указываем Python "распаковать" его, передавая его в `UserInDB`, добавив перед ним `**`.

Таким образом, мы получаем Pydantic-модель из данных другой Pydantic-модели.

#### Распаковка `dict` и дополнительные именованные аргументы

И затем, если мы добавим дополнительный именованный аргумент `hashed_password=hashed_password`, как здесь:

```Python
UserInDB(**user_in.dict(), hashed_password=hashed_password)
```

...это будет равно:

```Python
UserInDB(
    username = user_dict["username"],
    password = user_dict["password"],
    email = user_dict["email"],
    full_name = user_dict["full_name"],
    hashed_password = hashed_password,
)
```

/// warning | Предупреждение

Используемые в примере вспомогательные функции `fake_password_hasher` и `fake_save_user` служат лишь для демонстрации возможного потока данных, но, конечно, они не обеспечивают настоящую безопасность.

///

## Сократите дублирование

Сокращение дублирования кода — одна из основных идей **FastAPI**.

Поскольку дублирование кода увеличивает риск появления багов, проблем с безопасностью, проблем десинхронизации кода (когда вы обновляете код в одном месте, но не обновляете в другом), и т.д.

И все эти модели разделяют много данных и дублируют названия и типы атрибутов.

Мы могли бы сделать лучше.

Мы можем объявить модель `UserBase`, которая будет базовой для остальных моделей. И затем мы можем создать подклассы этой модели, которые будут наследовать её атрибуты (объявления типов, валидацию и т.п.).

Все операции конвертации, валидации, документации и т.п. будут по-прежнему работать нормально.

Таким образом, мы можем определить только отличия между моделями (с открытым `password`, с `hashed_password` и без пароля):

{* ../../docs_src/extra_models/tutorial002_py310.py hl[7,13:14,17:18,21:22] *}

## `Union` или `anyOf`

Вы можете объявить ответ как `Union` из двух или более типов, это значит, что ответ должен соответствовать одному из них.

Он будет определён в OpenAPI как `anyOf`.

Для этого используйте стандартный аннотацию типа Python <a href="https://docs.python.org/3/library/typing.html#typing.Union" class="external-link" target="_blank">`typing.Union`</a>:

/// note | Примечание

При определении <a href="https://docs.pydantic.dev/latest/concepts/types/#unions" class="external-link" target="_blank">`Union`</a>, сначала указывайте самый специфичный тип, затем менее специфичные. В примере ниже более специфичный `PlaneItem` идёт перед `CarItem` в `Union[PlaneItem, CarItem]`.

///

{* ../../docs_src/extra_models/tutorial003_py310.py hl[1,14:15,18:20,33] *}

### `Union` в Python 3.10

В этом примере мы передаём `Union[PlaneItem, CarItem]` как значение аргумента `response_model`.

Поскольку мы передаём его как **значение для аргумента**, а не помещаем его в **аннотацию типа**, нам необходимо использовать `Union` даже в Python 3.10.

Если бы это было в аннотации типа, мы могли бы использовать вертикальную черту, как в примере:

```Python
some_variable: PlaneItem | CarItem
```

Но если мы поместим это в `response_model=PlaneItem | CarItem`, мы получим ошибку, потому что Python попытается произвести **некорректную операцию** между `PlaneItem` и `CarItem` вместо того, чтобы интерпретировать это как аннотацию типа.

## Список моделей

Аналогичным образом вы можете объявить ответы как списки объектов.

Для этого используйте стандартный Python `typing.List` (или просто `list` в Python 3.9 и выше):

{* ../../docs_src/extra_models/tutorial004_py39.py hl[18] *}

## Ответ с произвольным `dict`

Вы также можете объявлять ответ, используя простой необязательный `dict`, определяя только типы ключей и значений без использования Pydantic-моделей.

Это полезно, если вы заранее не знаете допустимые названия полей/атрибутов (которые понадобятся для использования Pydantic-модели).

В этом случае вы можете использовать `typing.Dict` (или просто `dict` в Python 3.9 и выше):

{* ../../docs_src/extra_models/tutorial005_py39.py hl[6] *}

## Резюме

Используйте несколько Pydantic-моделей и свободно наследуйте для каждого случая.

Вам не обязательно иметь единственную модель данных для каждой сущности, если эта сущность должна иметь возможность существовать в разных "состояниях". Как в случае с "сущностью" пользователя с состояниями, включающими `password`, `password_hash` и без пароля.
