# За прокси-сервером

В некоторых ситуациях вам может понадобиться использовать **прокси**-сервер, такой как Traefik или Nginx, с конфигурацией, добавляющей дополнительный префикс к path, который ваше приложение не видит.

В таких случаях вы можете использовать `root_path` для настройки вашего приложения.

`root_path` — это механизм, предоставляемый спецификацией ASGI (на основе которой построен FastAPI через Starlette).

`root_path` используется для обработки этих конкретных случаев.

Он также используется внутренне при монтировании подприложений.

## Прокси с вырезанным префиксом path

Использование прокси с вырезанным префиксом path означает, что вы можете объявить путь как `/app` в своем коде. Но затем вы добавляете слой сверху (прокси), который помещает ваше приложение **FastAPI** под путь, такой как `/api/v1`.

В этом случае оригинальный путь `/app` будет фактически работать как `/api/v1/app`.

Несмотря на то, что весь ваш код написан с учетом использования только `/app`.

{* ../../docs_src/behind_a_proxy/tutorial001.py hl[6] *}

И прокси будет **"вырезать"** **префикс пути** на лету перед передачей запроса серверу приложения (вероятно, Uvicorn через CLI FastAPI), оставляя ваше приложение уверенным, что оно работает на `/app`, чтобы вам не пришлось обновлять весь код для включения префикса `/api/v1`.

До этого момента все будет работать как обычно.

Но затем, когда вы откроете встроенный интерфейс документации (фронтенд), он будет ожидать получить OpenAPI-схему на `/openapi.json`, вместо `/api/v1/openapi.json`.

Поэтому фронтенд (который работает в браузере) попытается достичь `/openapi.json` и не сможет получить OpenAPI-схему.

Поскольку у нас есть прокси с префиксом пути `/api/v1` для нашего приложения, фронтенд должен получить OpenAPI-схему на `/api/v1/openapi.json`.

```mermaid
graph LR

browser("Браузер")
proxy["Прокси на http://0.0.0.0:9999/api/v1/app"]
server["Сервер на http://127.0.0.1:8000/app"]

browser --> proxy
proxy --> server
```

/// совет | Совет

IP `0.0.0.0` обычно используется, чтобы указать, что программа слушает все доступные IP-адреса на этой машине/сервере.

///

Интерфейс документации также будет нуждаться в OpenAPI-схеме для декларации, что этот API `server` расположен на `/api/v1` (за прокси). Например:

```JSON hl_lines="4-8"
{
    "openapi": "3.1.0",
    // Другие данные здесь
    "servers": [
        {
            "url": "/api/v1"
        }
    ],
    "paths": {
            // Другие данные здесь
    }
}
```

В этом примере "Прокси" может быть чем-то вроде **Traefik**. А сервером может быть что-то вроде CLI FastAPI с **Uvicorn**, который запускает ваше приложение FastAPI.

### Указание `root_path`

Чтобы достичь этого, вы можете использовать командную строку с опцией `--root-path`, например:

<div class="termy">

```console
$ fastapi run main.py --root-path /api/v1

<span style="color: green;">INFO</span>:     Uvicorn запущен на http://127.0.0.1:8000 (Нажмите CTRL+C для остановки)
```

</div>

Если вы используете Hypercorn, у него также есть опция `--root-path`.

/// note | Технические подробности

Спецификация ASGI определяет `root_path` для этого случая использования.

И опция командной строки `--root-path` предоставляет этот `root_path`.

///

### Проверка текущего `root_path`

Вы можете получить текущий `root_path`, используемый вашим приложением для каждого запроса, он является частью словаря `scope` (это часть спецификации ASGI).

Здесь мы включаем его в сообщение просто для демонстрации.

{* ../../docs_src/behind_a_proxy/tutorial001.py hl[8] *}

Затем, если вы запустите Uvicorn с:

<div class="termy">

```console
$ fastapi run main.py --root-path /api/v1

<span style="color: green;">INFO</span>:     Uvicorn запущен на http://127.0.0.1:8000 (Нажмите CTRL+C для остановки)
```

</div>

Ответ будет что-то вроде:

```JSON
{
    "message": "Hello World",
    "root_path": "/api/v1"
}
```

### Установка `root_path` в приложении FastAPI

Альтернативно, если у вас нет возможности предоставить опцию командной строки, такую как `--root-path` или аналогичную, вы можете установить параметр `root_path` при создании вашего приложения FastAPI:

{* ../../docs_src/behind_a_proxy/tutorial002.py hl[3] *}

Передача `root_path` в `FastAPI` будет эквивалентна передаче опции командной строки `--root-path` для Uvicorn или Hypercorn.

### О `root_path`

Учтите, что сервер (Uvicorn) не будет использовать `root_path` ни для чего, кроме передачи его приложению.

Но если вы зайдете через браузер по адресу <a href="http://127.0.0.1:8000" class="external-link" target="_blank">http://127.0.0.1:8000/app</a>, вы увидите обычный ответ:

```JSON
{
    "message": "Hello World",
    "root_path": "/api/v1"
}
```

Итак, он не будет ожидать доступа по адресу `http://127.0.0.1:8000/api/v1/app`.

Uvicorn будет ожидать, что прокси получит доступ к Uvicorn по адресу `http://127.0.0.1:8000/app`, а затем это будет уже ответственность прокси — добавить дополнительный префикс `/api/v1`.

## О прокси с вырезанным префиксом path

Имейте в виду, что прокси с вырезанным префиксом path — это всего лишь один из способов его настройки.

Вероятно, во многих случаях по умолчанию будет то, что у прокси нет вырезанного префикса path.

В случае, подобном этому (без вырезанного префикса path), прокси будет слушать что-то вроде `https://myawesomeapp.com`, и тогда, если браузер перейдет на `https://myawesomeapp.com/api/v1/app`, а ваш сервер (например, Uvicorn) слушает на `http://127.0.0.1:8000`, прокси (без вырезанного префикса path) получит доступ к Uvicorn на том же пути: `http://127.0.0.1:8000/api/v1/app`.

## Тестирование локально с Traefik

Вы можете легко провести эксперимент локально с вырезанным префиксом path, используя <a href="https://docs.traefik.io/" class="external-link" target="_blank">Traefik</a>.

<a href="https://github.com/containous/traefik/releases" class="external-link" target="_blank">Скачайте Traefik</a>, это один исполняемый файл, вы можете извлечь сжатый файл и запустить его прямо из терминала.

Затем создайте файл `traefik.toml` с:

```TOML hl_lines="3"
[entryPoints]
  [entryPoints.http]
    address = ":9999"

[providers]
  [providers.file]
    filename = "routes.toml"
```

Это указывает Traefik слушать на порту 9999 и использовать другой файл `routes.toml`.

/// совет

Мы используем порт 9999 вместо стандартного порта HTTP 80, чтобы вам не пришлось запускать это с привилегиями администратора (`sudo`).

///

Теперь создайте другой файл `routes.toml`:

```TOML hl_lines="5  12  20"
[http]
  [http.middlewares]

    [http.middlewares.api-stripprefix.stripPrefix]
      prefixes = ["/api/v1"]

  [http.routers]

    [http.routers.app-http]
      entryPoints = ["http"]
      service = "app"
      rule = "PathPrefix(`/api/v1`)"
      middlewares = ["api-stripprefix"]

  [http.services]

    [http.services.app]
      [http.services.app.loadBalancer]
        [[http.services.app.loadBalancer.servers]]
          url = "http://127.0.0.1:8000"
```

Этот файл настраивает Traefik для использования префикса path `/api/v1`.

А затем Traefik перенаправит свои запросы на ваш Uvicorn, запущенный на `http://127.0.0.1:8000`.

Теперь запустите Traefik:

<div class="termy">

```console
$ ./traefik --configFile=traefik.toml

INFO[0000] Конфигурация загружена из файла: /home/user/awesomeapi/traefik.toml
```

</div>

И теперь запустите ваше приложение, используя опцию `--root-path`:

<div class="termy">

```console
$ fastapi run main.py --root-path /api/v1

<span style="color: green;">INFO</span>:     Uvicorn запущен на http://127.0.0.1:8000 (Нажмите CTRL+C для остановки)
```

</div>

### Проверьте ответы

Теперь, если вы перейдете по URL с портом для Uvicorn: <a href="http://127.0.0.1:8000/app" class="external-link" target="_blank">http://127.0.0.1:8000/app</a>, вы увидите нормальный ответ:

```JSON
{
    "message": "Hello World",
    "root_path": "/api/v1"
}
```

/// совет | Совет

Обратите внимание, что, хотя вы получаете доступ к нему по адресу `http://127.0.0.1:8000/app`, он отображает `root_path` как `/api/v1`, взятый из опции `--root-path`.

///

А теперь откройте URL с портом для Traefik, включая префикс path: <a href="http://127.0.0.1:9999/api/v1/app" class="external-link" target="_blank">http://127.0.0.1:9999/api/v1/app</a>.

Мы получаем такой же ответ:

```JSON
{
    "message": "Hello World",
    "root_path": "/api/v1"
}
```

но на этот раз по URL с префиксом path, предоставленным прокси: `/api/v1`.

Конечно, идея здесь в том, что все должны получить доступ к приложению через прокси, так что версия с префиксом path `/api/v1` — это "правильная" версия.

И версия без префикса path (`http://127.0.0.1:8000/app`), предоставляемая напрямую Uvicorn, будет исключительно для _прокси_ (Traefik), чтобы получить к ней доступ.

Это демонстрирует, как прокси (Traefik) использует префикс path и как сервер (Uvicorn) использует `root_path` из опции `--root-path`.

### Проверьте интерфейс документации

Но вот где начинается веселье. ✨

"Официальный" способ доступа к приложению будет через прокси с префиксом path, который мы определили. Поэтому, как и ожидалось, если вы попытаетесь использовать интерфейс документации, обслуживаемый Uvicorn напрямую, без префикса path в URL, он не будет работать, потому что предполагается, что доступ будет осуществляться через прокси.

Вы можете проверить это по адресу <a href="http://127.0.0.1:8000/docs" class="external-link" target="_blank">http://127.0.0.1:8000/docs</a>:

<img src="/img/tutorial/behind-a-proxy/image01.png">

Но если мы получим доступ к интерфейсу документации по "официальному" URL, используя прокси с портом `9999`, по адресу `/api/v1/docs`, он работает правильно! 🎉

Вы можете проверить это по адресу <a href="http://127.0.0.1:9999/api/v1/docs" class="external-link" target="_blank">http://127.0.0.1:9999/api/v1/docs</a>:

<img src="/img/tutorial/behind-a-proxy/image02.png">

Как и хотели. ✔️

Это потому, что FastAPI использует этот `root_path` для создания `server` по умолчанию в OpenAPI с URL, предоставленным `root_path`.

## Дополнительные серверы

/// warning | Предупреждение

Это более сложный случай использования. Вы можете пропустить его, если хотите.

///

По умолчанию **FastAPI** создаст `server` в схеме OpenAPI с URL для `root_path`.

Но вы также можете предоставить другие альтернативные `servers`, например, если вы хотите, чтобы *этот же* интерфейс документации взаимодействовал как со средой тестирования, так и со средой продакшн.

Если вы передаете пользовательский список `servers` и существует `root_path` (потому что ваш API находится за прокси), **FastAPI** вставит "server" с этим `root_path` в начало списка.

Например:

{* ../../docs_src/behind_a_proxy/tutorial003.py hl[4:7] *}

Создаст схему OpenAPI, как:

```JSON hl_lines="5-7"
{
    "openapi": "3.1.0",
    // Другие данные здесь
    "servers": [
        {
            "url": "/api/v1"
        },
        {
            "url": "https://stag.example.com",
            "description": "Тестовая среда"
        },
        {
            "url": "https://prod.example.com",
            "description": "Продакшн среда"
        }
    ],
    "paths": {
            // Другие данные здесь
    }
}
```

/// совет | Совет

Обратите внимание на автоматически сгенерированный сервер с `url` значением `/api/v1`, взятым из `root_path`.

///

В интерфейсе документации по адресу <a href="http://127.0.0.1:9999/api/v1/docs" class="external-link" target="_blank">http://127.0.0.1:9999/api/v1/docs</a> это будет выглядеть так:

<img src="/img/tutorial/behind-a-proxy/image03.png">

/// совет | Совет

Интерфейс документации будет взаимодействовать с сервером, который вы выберете.

///

### Отключение автоматического сервера от `root_path`

Если вы не хотите, чтобы **FastAPI** включал автоматический сервер, используя `root_path`, вы можете использовать параметр `root_path_in_servers=False`:

{* ../../docs_src/behind_a_proxy/tutorial004.py hl[9] *}

и тогда он не будет включен в схему OpenAPI.

## Монтирование подприложения

Если вам нужно смонтировать подприложение (как описано в [Подприложения - Монтирование](sub-applications.md){.internal-link target=_blank}), используя также прокси с `root_path`, вы можете сделать это обычным образом, как и ожидалось.

FastAPI будет использовать `root_path` умно, поэтому все будет работать, как и задумано. ✨
