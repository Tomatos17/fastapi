# За прокси

В некоторых случаях вам может понадобиться воспользоваться сервером **прокси**, таким как Traefik или Nginx, с конфигурацией, которая добавляет дополнительный префикс пути, не видимый вашему приложению.

В таких случаях вы можете использовать `root_path` для настройки вашего приложения.

`root_path` — это механизм, предусмотренный спецификацией ASGI (на которой построен FastAPI через Starlette).

`root_path` используется для обработки этих специфических случаев.

Также он используется внутренне при монтировании подприложений.

## Прокси с обрезанным префиксом пути

Наличие прокси с обрезанным префиксом пути в этом случае означает, что вы можете объявить путь `/app` в вашем коде, но затем добавить слой сверху (прокси), который поместит ваше приложение **FastAPI** под путь вроде `/api/v1`.

В этом случае изначальный путь `/app` на самом деле будет обслуживаться по адресу `/api/v1/app`.

Хотя весь ваш код написан, предполагая, что существует только `/app`.

{* ../../docs_src/behind_a_proxy/tutorial001.py hl[6] *}

И прокси будет **"обрезать"** **префикс пути** на лету перед передачей запроса на сервер приложения (вероятно, через FastAPI CLI через Uvicorn), оставляя ваше приложение уверенным в том, что оно обслуживается по адресу `/app`, чтобы вам не нужно было обновлять весь ваш код для включения префикса `/api/v1`.

До этого момента все будет работать как обычно.

Но затем, когда вы откроете интегрированный интерфейс документации (фронтенд), он будет ожидать, что получит схему OpenAPI по адресу `/openapi.json`, вместо `/api/v1/openapi.json`.

Таким образом, фронтенд (который выполняется в браузере) попытается получить доступ к `/openapi.json` и не сможет получить схему OpenAPI.

Поскольку у нас есть прокси с префиксом пути `/api/v1` для нашего приложения, фронтенд должен получить схему OpenAPI по адресу `/api/v1/openapi.json`.

```mermaid
graph LR

browser("Браузер")
proxy["Прокси на http://0.0.0.0:9999/api/v1/app"]
server["Сервер на http://127.0.0.1:8000/app"]

browser --> proxy
proxy --> server
```

/// tip | Совет

IP `0.0.0.0` обычно используется, чтобы указать, что программа слушает все доступные IP-адреса на этой машине/сервере.

///

UI документации также будет нужна схема OpenAPI, чтобы указать, что этот API `server` находится по адресу `/api/v1` (за прокси). Например:

```JSON hl_lines="4-8"
{
    "openapi": "3.1.0",
    // Другие данные здесь
    "servers": [
        {
            "url": "/api/v1"
        }
    ],
    "paths": {
            // Другие данные здесь
    }
}
```

В этом примере "Прокси" может быть чем-то вроде **Traefik**. А сервер будет чем-то вроде FastAPI CLI с **Uvicorn**, выполняющим ваше приложение FastAPI.

### Предоставление `root_path`

Для этого вы можете использовать параметр командной строки `--root-path`, например:

<div class="termy">

```console
$ fastapi run main.py --root-path /api/v1

<span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
```

</div>

Если вы используете Hypercorn, у него также есть опция `--root-path`.

/// note | Технические детали

Спецификация ASGI определяет `root_path` для этого случая использования.

А параметр командной строки `--root-path` предоставляет этот `root_path`.

///

### Проверка текущего `root_path`

Вы можете получить текущий `root_path`, используемый вашим приложением для каждого запроса, он является частью словаря `scope` (который является частью спецификации ASGI).

Здесь мы приводим его в сообщении только для демонстрационных целей.

{* ../../docs_src/behind_a_proxy/tutorial001.py hl[8] *}

Затем, если вы запустите Uvicorn с:

<div class="termy">

```console
$ fastapi run main.py --root-path /api/v1

<span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
```

</div>

Ответ будет таким:

```JSON
{
    "message": "Здравствуй, мир",
    "root_path": "/api/v1"
}
```

### Установка `root_path` в приложении FastAPI

В качестве альтернативы, если у вас нет возможности предоставить параметр командной строки, такой как `--root-path` или эквивалентный, вы можете установить параметр `root_path` при создании вашего приложения FastAPI:

{* ../../docs_src/behind_a_proxy/tutorial002.py hl[3] *}

Передача `root_path` в `FastAPI` будет эквивалентна передаче параметра командной строки `--root-path` в Uvicorn или Hypercorn.

### О `root_path`

Учтите, что сервер (Uvicorn) не будет использовать этот `root_path` для чего-либо, кроме передачи его в приложение.

Но если вы пойдете с вашим браузером на <a href="http://127.0.0.1:8000" class="external-link" target="_blank">http://127.0.0.1:8000/app</a>, вы увидите нормальный ответ:

```JSON
{
    "message": "Здравствуй, мир",
    "root_path": "/api/v1"
}
```

Таким образом, он не будет ожидать доступа по адресу `http://127.0.0.1:8000/api/v1/app`.

Uvicorn будет ожидать, что прокси будет обращаться к Uvicorn по адресу `http://127.0.0.1:8000/app`, и тогда это будет обязанностью прокси добавить дополнительный префикс `/api/v1` поверх.

## О прокси с обрезанным префиксом пути

Учтите, что использование прокси с обрезанным префиксом пути — это только один из способов его настройки.

Вероятно, в большинстве случаев по умолчанию прокси не будет иметь обрезанного префикса пути.

В таком случае (без обрезанного префикса пути) прокси будет слушать что-то вроде `https://myawesomeapp.com`, и тогда, если браузер зайдет на `https://myawesomeapp.com/api/v1/app`, а ваш сервер (например, Uvicorn) слушает на `http://127.0.0.1:8000`, прокси (без обрезанного префикса пути) будет обращаться к Uvicorn по тому же пути: `http://127.0.0.1:8000/api/v1/app`.

## Тестирование локально с Traefik

Вы можете легко запустить эксперимент локально с обрезанным префиксом пути, используя <a href="https://docs.traefik.io/" class="external-link" target="_blank">Traefik</a>.

<a href="https://github.com/containous/traefik/releases" class="external-link" target="_blank">Скачайте Traefik</a>, это единый исполняемый файл, вы можете извлечь сжатый файл и запустить его напрямую из терминала.

Затем создайте файл `traefik.toml` со следующим содержимым:

```TOML hl_lines="3"
[entryPoints]
  [entryPoints.http]
    address = ":9999"

[providers]
  [providers.file]
    filename = "routes.toml"
```

Это указывает Traefik слушать на порту 9999 и использовать другой файл `routes.toml`.

/// tip | Совет

Мы используем порт 9999 вместо стандартного HTTP-порта 80, чтобы вам не нужно было запускать его с административными (`sudo`) привилегиями.

///

Теперь создайте другой файл `routes.toml`:

```TOML hl_lines="5  12  20"
[http]
  [http.middlewares]

    [http.middlewares.api-stripprefix.stripPrefix]
      prefixes = ["/api/v1"]

  [http.routers]

    [http.routers.app-http]
      entryPoints = ["http"]
      service = "app"
      rule = "PathPrefix(`/api/v1`)"
      middlewares = ["api-stripprefix"]

  [http.services]

    [http.services.app]
      [http.services.app.loadBalancer]
        [[http.services.app.loadBalancer.servers]]
          url = "http://127.0.0.1:8000"
```

Этот файл настраивает Traefik на использование префикса пути `/api/v1`.

И затем Traefik будет перенаправлять свои запросы на ваш Uvicorn, работающий на `http://127.0.0.1:8000`.

Теперь запустите Traefik:

<div class="termy">

```console
$ ./traefik --configFile=traefik.toml

INFO[0000] Configuration loaded from file: /home/user/awesomeapi/traefik.toml
```

</div>

И теперь запустите ваше приложение, используя параметр `--root-path`:

<div class="termy">

```console
$ fastapi run main.py --root-path /api/v1

<span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
```

</div>

### Проверка ответов

Теперь, если вы перейдете по URL-адресу с портом для Uvicorn: <a href="http://127.0.0.1:8000/app" class="external-link" target="_blank">http://127.0.0.1:8000/app</a>, вы увидите стандартный ответ:

```JSON
{
    "message": "Здравствуй, мир",
    "root_path": "/api/v1"
}
```

/// tip | Совет

Заметьте, что, хотя вы обращаетесь к нему по адресу `http://127.0.0.1:8000/app`, он показывает `root_path` как `/api/v1`, взятый из параметра `--root-path`.

///

А теперь откройте URL с портом для Traefik, включая префикс пути: <a href="http://127.0.0.1:9999/api/v1/app" class="external-link" target="_blank">http://127.0.0.1:9999/api/v1/app</a>.

Мы получаем такой же ответ:

```JSON
{
    "message": "Здравствуй, мир",
    "root_path": "/api/v1"
}
```

только на этот раз по адресу URL с префиксом, предоставленным прокси: `/api/v1`.

Конечно, идея в том, чтобы все получали доступ к приложению через прокси, поэтому версия с префиксом пути `/api/v1` является "правильной".

А версия без префикса пути (`http://127.0.0.1:8000/app`), предоставленная напрямую Uvicorn, будет исключительно для доступа _прокси_ (Traefik) к нему.

Это демонстрирует, как прокси (Traefik) использует префикс пути и как сервер (Uvicorn) использует `root_path` из параметра `--root-path`.

### Проверка UI документации

Но вот интересная часть. ✨

"Официальный" способ доступа к приложению будет через прокси с префиксом пути, который мы определили. Таким образом, как мы и ожидали, если вы попытаетесь использовать UI документации, предоставляемый напрямую Uvicorn, без префикса пути в URL, это не будет работать, так как он ожидает, что доступ будет через прокси.

Вы можете проверить это на <a href="http://127.0.0.1:8000/docs" class="external-link" target="_blank">http://127.0.0.1:8000/docs</a>:

<img src="/img/tutorial/behind-a-proxy/image01.png">

Но если мы получим доступ к UI документации по "официальному" URL с использованием прокси с портом `9999`, по `/api/v1/docs`, он работает правильно! 🎉

Можно проверить это на <a href="http://127.0.0.1:9999/api/v1/docs" class="external-link" target="_blank">http://127.0.0.1:9999/api/v1/docs</a>:

<img src="/img/tutorial/behind-a-proxy/image02.png">

Точно так, как мы и хотели. ✔️

Это потому, что FastAPI использует этот `root_path` для создания стандартного `server` в OpenAPI с URL, предоставленным `root_path`.

## Дополнительные серверы

/// warning | Предупреждение

Это более сложный случай использования. Смело пропускайте его.

///

По умолчанию **FastAPI** создаст `server` в схеме OpenAPI с URL для `root_path`.

Но вы также можете предоставить другие альтернативные `servers`, например, если вы хотите, чтобы *тот же* UI документации взаимодействовал как с окружением для тестирования, так и с производственным окружением.

Если вы передадите кастомный список `servers` и присутствует `root_path` (потому что ваш API находится за прокси), **FastAPI** вставит "server" с этим `root_path` в начало списка.

Например:

{* ../../docs_src/behind_a_proxy/tutorial003.py hl[4:7] *}

Сгенерирует схему OpenAPI, такую как:

```JSON hl_lines="5-7"
{
    "openapi": "3.1.0",
    // Другие данные здесь
    "servers": [
        {
            "url": "/api/v1"
        },
        {
            "url": "https://stag.example.com",
            "description": "Staging environment"
        },
        {
            "url": "https://prod.example.com",
            "description": "Production environment"
        }
    ],
    "paths": {
            // Другие данные здесь
    }
}
```

/// tip | Совет

Обратите внимание на автоматически сгенерированный сервер с значением `url` `/api/v1`, взятое из `root_path`.

///

В UI документации по адресу <a href="http://127.0.0.1:9999/api/v1/docs" class="external-link" target="_blank">http://127.0.0.1:9999/api/v1/docs</a> это будет выглядеть так:

<img src="/img/tutorial/behind-a-proxy/image03.png">

/// tip | Совет

UI документации будет взаимодействовать с сервером, который вы выберете.

///

### Отключить автоматический сервер из `root_path`

Если вы не хотите, чтобы **FastAPI** включал автоматический сервер, используя `root_path`, вы можете использовать параметр `root_path_in_servers=False`:

{* ../../docs_src/behind_a_proxy/tutorial004.py hl[9] *}

и тогда он не будет включен в схему OpenAPI.

## Монтирование подприложения

Если вам нужно смонтировать подприложение (как описано в [Подприложения - Монтирование](sub-applications.md){.internal-link target=_blank}), при этом используя прокси с `root_path`, вы можете сделать это нормально, как вы и ожидаете.

FastAPI будет внутри использовать `root_path` умно, так что все будет просто работать. ✨
