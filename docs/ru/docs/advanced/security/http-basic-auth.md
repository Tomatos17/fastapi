# HTTP Базовая Аутентификация

Для самых простых случаев вы можете использовать HTTP Базовую Аутентификацию.

В HTTP Базовой Аутентификации, приложение ожидает заголовок, содержащий имя пользователя и пароль.

Если оно не получает его, то возвращает ошибку HTTP 401 "Unauthorized".

Также возвращается заголовок `WWW-Authenticate` со значением `Basic` и необязательный параметр `realm`.

Это сообщает браузеру показать встроенное окно запроса имени пользователя и пароля.

Затем, когда вы вводите это имя пользователя и пароль, браузер отправляет их в заголовке автоматически.

## Простая HTTP Базовая Аутентификация

* Импортируйте `HTTPBasic` и `HTTPBasicCredentials`.
* Создайте "`сущность` схемы безопасности" с использованием `HTTPBasic`.
* Используйте эту `схему безопасности` с зависимостью в вашем *путевом обработчике*.
* Это возвращает объект типа `HTTPBasicCredentials`:
    * Он содержит `username` и `password`, которые были отправлены.

{* ../../docs_src/security/tutorial006_an_py39.py hl[4,8,12] *}

Когда вы попробуете открыть URL в первый раз (или нажмёте кнопку "Execute" в документации), браузер запросит у вас ввод имени пользователя и пароля:

<img src="/img/tutorial/security/image12.png">

## Проверка имени пользователя

Вот более полный пример.

Используйте зависимость, чтобы проверить, правильны ли имя пользователя и пароль.

Для этого используйте стандартный модуль Python <a href="https://docs.python.org/3/library/secrets.html" class="external-link" target="_blank">`secrets`</a>, чтобы проверить имя пользователя и пароль.

`secrets.compare_digest()` должен принимать `bytes` или `str`, который содержит только символы ASCII (те, которые в английском языке), это значит, что он не будет работать с такими символами, как `á`, как в `Sebastián`.

Чтобы обработать это, мы сначала преобразуем `username` и `password` в `bytes`, кодируя их с помощью UTF-8.

Затем мы можем использовать `secrets.compare_digest()`, чтобы убедиться, что `credentials.username` равен `"stanleyjobson"`, а `credentials.password` равен `"swordfish"`.

{* ../../docs_src/security/tutorial007_an_py39.py hl[1,12:24] *}

Это будет аналогично:

```Python
if not (credentials.username == "stanleyjobson") or not (credentials.password == "swordfish"):
    # Возвращаем какую-то ошибку
    ...
```

Но, используя `secrets.compare_digest()`, это будет безопасно от типа атак, называемых "атаки по времени".

### Атаки по времени

Что же такое "атака по времени"?

Представьте, что некоторые злоумышленники пытаются угадать имя пользователя и пароль.

И они отправляют запрос с именем пользователя `johndoe` и паролем `love123`.

Тогда Python-код в вашем приложении будет аналогичен чему-то такому:

```Python
if "johndoe" == "stanleyjobson" and "love123" == "swordfish":
    ...
```

Но в тот момент, когда Python сравнивает первую `j` в `johndoe` с первой `s` в `stanleyjobson`, он вернёт `False`, потому что уже знает, что эти строки не одинаковы, считая, что "нет смысла тратить больше вычислений на сравнение оставшихся букв". И ваше приложение скажет "Неверное имя пользователя или пароль".

Но затем злоумышленники пробуют с именем пользователя `stanleyjobsox` и паролем `love123`.

И ваш код в приложении делает что-то похожее:

```Python
if "stanleyjobsox" == "stanleyjobson" and "love123" == "swordfish":
    ...
```

Python должен будет сравнить весь `stanleyjobso` в обоих `stanleyjobsox` и `stanleyjobson` перед тем, как осознать, что эти две строки не одинаковы. Поэтому для возвращения "Неверное имя пользователя или пароль" потребуется немного больше времени.

#### Время ответа помогает злоумышленникам

В этот момент, заметив, что сервер потратил несколько микросекунд дольше для отправки ответа "Неверное имя пользователя или пароль", злоумышленники будут знать, что они угадали _что-то_ правильно, некоторые начальные буквы были правильными.

И затем они могут попробовать снова, зная, что это, вероятно, что-то больше похожее на `stanleyjobsox`, чем на `johndoe`.

#### "Профессиональная" атака

Конечно, злоумышленники не будут пробовать все это вручную, они напишут программу, чтобы сделать это, возможно, с тысячами или миллионами тестов в секунду. И они получат только одну дополнительную правильную букву за раз.

Но, делая это, за несколько минут или часов злоумышленники могут угадать правильное имя пользователя и пароль с "помощью" нашего приложения, просто используя время, взятое на ответ.

#### Исправьте это с помощью `secrets.compare_digest()`

Но в нашем коде мы фактически используем `secrets.compare_digest()`.

Вкратце, это займет одинаковое время для сравнения `stanleyjobsox` с `stanleyjobson`, как и для сравнения `johndoe` с `stanleyjobson`. И то же самое для пароля.

Таким образом, используя `secrets.compare_digest()` в вашем коде приложения, оно будет безопасным от всего этого множества атак на безопасность.

### Возвращение ошибки

После обнаружения, что учетные данные неверны, верните `HTTPException` со статусным кодом 401 (тем же, что возвращается, когда учетные данные не предоставлены) и добавьте заголовок `WWW-Authenticate`, чтобы заставить браузер снова показать приглашение о вводе данных:

{* ../../docs_src/security/tutorial007_an_py39.py hl[26:30] *}
