# HTTP Basic Auth

Для самых простых случаев можно использовать HTTP Basic Auth.

В HTTP Basic Auth приложение ожидает HTTP-заголовок, содержащий имя пользователя и пароль.

Если он не получит их, то вернет ошибку HTTP 401 "Unauthorized" (неавторизовано).

Также будет возвращен HTTP-заголовок `WWW-Authenticate` со значением `Basic` и опциональным параметром `realm`.

Это говорит браузеру показать встроенную панель для ввода имени пользователя и пароля.

Затем, когда вы вводите эти имя пользователя и пароль, браузер отправляет их в заголовке автоматически.

## Простая HTTP Basic Auth

* Импортируйте `HTTPBasic` и `HTTPBasicCredentials`.
* Создайте "`security` scheme" используя `HTTPBasic`.
* Используйте эту `security` зависимость в вашей *операции пути*.
* Она возвращает объект типа `HTTPBasicCredentials`:
    * Содержит отправленные `username` и `password`.

{* ../../docs_src/security/tutorial006_an_py39.py hl[4,8,12] *}

Когда вы попытаетесь открыть URL в первый раз (или нажмете кнопку "Execute" в документации) браузер спросит вас имя пользователя и пароль:

<img src="/img/tutorial/security/image12.png">

## Проверка имени пользователя

Вот более полный пример.

Используйте зависимость, чтобы проверить, правильные ли имя пользователя и пароль.

Для этого используйте стандартный модуль Python <a href="https://docs.python.org/3/library/secrets.html" class="external-link" target="_blank">`secrets`</a> для проверки имени пользователя и пароля.

`secrets.compare_digest()` требует `bytes` или `str`, содержащий только ASCII-символы (те, что на английском), это значит, что он не будет работать с символами, такими как `á`, например в `Sebastián`.

Чтобы с этим справиться, мы сначала конвертируем `username` и `password` в `bytes`, кодируя их в UTF-8.

Затем мы можем использовать `secrets.compare_digest()` для гарантии, что `credentials.username` равен `"stanleyjobson"`, а `credentials.password` равен `"swordfish"`.

{* ../../docs_src/security/tutorial007_an_py39.py hl[1,12:24] *}

Это будет аналогично:

```Python
if not (credentials.username == "stanleyjobson") or not (credentials.password == "swordfish"):
    # Return some error
    ...
```

Но, используя `secrets.compare_digest()`, это будет защищено от атак под названием "тайминговые атаки".

### Тайминговые атаки

Что такое "тайминговая атака"?

Представим, что некоторая группа злоумышленников пытается угадать имя пользователя и пароль.

Они отправляют запрос с именем пользователя `johndoe` и паролем `love123`.

Тогда Python-код в вашем приложении будет эквивалентен чему-то вроде:

```Python
if "johndoe" == "stanleyjobson" and "love123" == "swordfish":
    ...
```

Но в тот момент, когда Python сравнивает первую `j` в `johndoe` с первой `s` в `stanleyjobson`, он вернет `False`, так как уже знает, что эти две строки не одинаковы, считая, что "нет смысла тратить больше вычислительных ресурсов на сравнение остальных букв". И ваше приложение скажет "Неправильное имя пользователя или пароль".

Но затем злоумышленники попробуют с именем пользователя `stanleyjobsox` и паролем `love123`.

И ваш код приложения делает что-то вроде:

```Python
if "stanleyjobsox" == "stanleyjobson" and "love123" == "swordfish":
    ...
```

Python должен будет сравнить весь `stanleyjobso` в `stanleyjobsox` и `stanleyjobson`, чтобы понять, что строки не одинаковы. Так что это займет дополнительные микросекунды, чтобы ответить "Неправильное имя пользователя или пароль".

#### Время ответа помогает злоумышленникам

В этот момент, заметив, что серверу понадобилось немного больше времени, чтобы отправить ответ "Неправильное имя пользователя или пароль", злоумышленники узнают, что они что-то угадали, некоторые начальные буквы были правильными.

И тогда они могут попробовать снова, зная, что это, вероятно, что-то более похожее на `stanleyjobsox`, чем на `johndoe`.

#### "Профессиональная" атака

Конечно, злоумышленники не будут делать все это вручную, они напишут программу, чтобы делать это, возможно, с тысячами или миллионами тестов в секунду. И они будут получать лишь одну правильную букву за раз.

Но, делая так, за несколько минут или часов злоумышленники могли бы угадать правильное имя пользователя и пароль, с "помощью" нашего приложения, просто используя время, затраченное на ответ.

#### Исправьте это с помощью `secrets.compare_digest()`

Но в нашем коде мы фактически используем `secrets.compare_digest()`.

Вкратце, это займет одинаковое время, чтобы сравнить `stanleyjobsox` с `stanleyjobson`, как и `johndoe` с `stanleyjobson`. И то же самое для пароля.

Таким образом, используя `secrets.compare_digest()` в коде вашего приложения, оно будет защищено от этого целого спектра атак на безопасность.

### Возврат ошибки

После обнаружения, что учетные данные неверны, верните `HTTPException` с кодом состояния 401 (тот же, что возвращается, когда учетные данные не предоставлены) и добавьте заголовок `WWW-Authenticate`, чтобы браузер снова отобразил приглашение для входа:

{* ../../docs_src/security/tutorial007_an_py39.py hl[26:30] *}
