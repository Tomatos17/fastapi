# OAuth2 scope

Вы можете использовать OAuth2 scope напрямую с **FastAPI**, они интегрированы для работы без проблем.

Это позволит вам иметь более тонкую систему разрешений, следуя стандарту OAuth2, интегрированную в ваше OpenAPI приложение (и документы API).

OAuth2 с scope — это механизм, используемый многими крупными провайдерами аутентификации, такими как Facebook, Google, GitHub, Microsoft, Twitter и т.д. Они используют его для предоставления определенных разрешений пользователям и приложениям.

Каждый раз, когда вы "входите с помощью" Facebook, Google, GitHub, Microsoft, Twitter, это приложение использует OAuth2 с scope.

В этом разделе вы увидите, как управлять аутентификацией и авторизацией с использованием того же OAuth2 с scope в вашем приложении **FastAPI**.

/// warning | Предупреждение

Это более или менее сложный раздел. Если вы только начинаете, вы можете пропустить его.

Вы не обязательно нуждаетесь в OAuth2 scope, и можете обрабатывать аутентификацию и авторизацию, как вам угодно.

Но OAuth2 с scope может быть прекрасно интегрирован в ваш API (с OpenAPI) и в ваши документы API.

Тем не менее, вы все равно должны применять эти scope, или любые другие требования к безопасности/авторизации, так как вам нужно, в вашем коде.

В многих случаях, OAuth2 с scope может быть избыточными.

Но если вы знаете, что они вам нужны, или вы заинтересовались, продолжайте чтение.

///

## OAuth2 scope и OpenAPI

Спецификация OAuth2 определяет "scope" как список строк, разделенных пробелами.

Содержимое каждой из этих строк может иметь любой формат, но не должно содержать пробелов.

Эти scope представляют собой "разрешения".

В OpenAPI (например, в документах API) вы можете определить "схемы безопасности".

Когда одна из этих схем безопасности использует OAuth2, вы также можете объявлять и использовать scope.

Каждый "scope" — это просто строка (без пробелов).

Обычно они используются для объявления определенных разрешений безопасности, например:

* `users:read` или `users:write` — это распространенные примеры.
* `instagram_basic` используется Facebook/Instagram.
* `https://www.googleapis.com/auth/drive` используется Google.

/// info | Информация

В OAuth2 "scope" — это просто строка, указывающая на конкретные требуемые разрешения.

Не имеет значения, есть ли в нем другие символы, такие как `:`, или если это URL.

Эти детали специфичны для реализации.

Для OAuth2 они просто строки.

///

## Общее представление

Сначала давайте быстро посмотрим на части, которые изменяются по сравнению с примерами в основном **Учебнике - Руководстве пользователя** для [OAuth2 с Паролем (и хешированием), Bearer с JWT токенами](../../tutorial/security/oauth2-jwt.md){.internal-link target=_blank}. Теперь используя OAuth2 scope:

{* ../../docs_src/security/tutorial005_an_py310.py hl[5,9,13,47,65,106,108:116,122:125,129:135,140,156] *}

Теперь давайте рассмотрим эти изменения шаг за шагом.

## Схема безопасности OAuth2

Первое изменение состоит в том, что мы теперь объявляем схему безопасности OAuth2 с двумя доступными scope, `me` и `items`.

Параметр `scopes` принимает `dict`, где каждый scope указывается в качестве ключа, а описание — в качестве значения:

{* ../../docs_src/security/tutorial005_an_py310.py hl[63:66] *}

Поскольку мы теперь объявляем эти scope, они будут отображаться в документации API, когда вы входите/авторизируетесь.

И вы сможете выбрать, к каким scope вы хотите дать доступ: `me` и `items`.

Это тот же механизм, который используется, когда вы предоставляете разрешения при входе в Facebook, Google, GitHub и т.д:

<img src="/img/tutorial/security/image11.png">

## JWT токен с scope

Теперь модифицируйте токен *операции пути*, чтобы вернуть запрашиваемые scope.

Мы по-прежнему используем тот же `OAuth2PasswordRequestForm`. Он включает свойство `scopes` с `list` из `str`, в котором содержатся все scope, полученные в запросе.

И мы возвращаем scope как часть JWT токена.

/// danger | Опасность

Для упрощения, здесь мы просто добавляем полученные scope непосредственно в токен.

Но в вашем приложении, с целью безопасности, вы должны удостовериться, что добавляете только те scope, которые пользователь действительно может иметь, или те, которые вы заранее определили.

///

{* ../../docs_src/security/tutorial005_an_py310.py hl[156] *}

## Объявление scope в *операциях пути* и зависимостях

Теперь мы объявляем, что *операция пути* для `/users/me/items/` требует scope `items`.

Для этого мы импортируем и используем `Security` из `fastapi`.

Вы можете использовать `Security` для объявления зависимостей (так же как `Depends`), но `Security` также принимает параметр `scopes` со списком scope (строк).

В данном случае, мы передаем функцию зависимости `get_current_active_user` в `Security` (так же как мы бы делали это с `Depends`).

Но мы также передаем `list` с scope, в этом случае только с одним scope: `items` (хотя их может быть больше).

И функция зависимости `get_current_active_user` также может объявлять подзависимости, не только с `Depends`, но и с `Security`. Объявляя свою подзависимость (`get_current_user`), а также требования к scope.

В этом случае требуется scope `me` (могут требоваться и другие scope).

/// note | Примечание

Вам не обязательно нужно добавлять разные scope в разные места.

Мы делаем это здесь, чтобы продемонстрировать, как **FastAPI** обрабатывает scope, объявленные на разных уровнях.

///

{* ../../docs_src/security/tutorial005_an_py310.py hl[5,140,171] *}

/// info | Технические детали

`Security` на самом деле является подклассом `Depends`, и у него есть всего один дополнительный параметр, который мы рассмотрим позже.

Но используя `Security` вместо `Depends`, **FastAPI** будет знать, что он может объявить scope безопасности, использовать их внутри и документировать API с помощью OpenAPI.

Но когда вы импортируете `Query`, `Path`, `Depends`, `Security` и другие из `fastapi`, это на самом деле функции, которые возвращают специальные классы.

///

## Используйте `SecurityScopes`

Теперь обновите зависимость `get_current_user`.

Это та зависимость, которая используется выше.

Вот где мы используем ту же схему OAuth2, которую создали ранее, объявляя ее как зависимость: `oauth2_scheme`.

Поскольку эта функция зависимости не имеет собственных требований к scope, мы можем использовать `Depends` с `oauth2_scheme`, нам не нужно использовать `Security`, когда нам не нужно указывать scope безопасности.

Также мы объявляем специальный параметр типа `SecurityScopes`, импортированный из `fastapi.security`.

Этот класс `SecurityScopes` похож на `Request` (`Request` использовался для получения объекта запроса напрямую).

{* ../../docs_src/security/tutorial005_an_py310.py hl[9,106] *}

## Используйте `scopes`

Параметр `security_scopes` будет типа `SecurityScopes`.

У него есть свойство `scopes` со списком, содержащим все scope, требуемые как сама зависимость, так и все зависимости, которые используют это как подзависимость. Это значит, все "зависимые"... это может звучать запутанно, но это объясняется снова позже.

Объект `security_scopes` (класса `SecurityScopes`) также предоставляет атрибут `scope_str` с одной строкой, содержащей эти scope, разделенные пробелами (мы собираемся использовать его).

Мы создаем `HTTPException`, который мы можем использовать (`raise`) позже в нескольких повторяющихся моментах.

В этом исключении мы включаем требуемые scope (если они есть) в виде строки, разделенной пробелами (используя `scope_str`). Мы помещаем эту строку, содержащую scope, в HTTP-заголовке `WWW-Authenticate` (это часть спецификации).

{* ../../docs_src/security/tutorial005_an_py310.py hl[106,108:116] *}

## Проверьте `username` и форму данных

Мы проверяем, что получили `username`, и извлекаем scope.

Затем мы валидируем эти данные с помощью Pydantic-модели (обрабатывая исключение `ValidationError`), и если мы получаем ошибку при чтении JWT токена или валидации данных с Pydantic, мы вызываем `HTTPException`, который создали ранее.

Для этого мы обновляем Pydantic-модель `TokenData` с новым свойством `scopes`.

Валидируя данные с помощью Pydantic, мы можем убедиться, что у нас, например, точно есть `list` из `str` с scope и `str` с `username`.

Вместо, например, `dict`, или чего-то еще, так как это может сломать приложение в какой-то момент позже, создавая угрозу безопасности.

Мы также проверяем, что у нас есть пользователь с этим именем пользователя, и если нет, вызываем то же самое исключение, созданное ранее.

{* ../../docs_src/security/tutorial005_an_py310.py hl[47,117:128] *}

## Проверьте `scopes`

Теперь мы проверяем, все ли требуемые scope, этой зависимостью и всеми зависимыми (включая *операции пути*), включены в предоставленные токеном scope, в противном случае вызываем `HTTPException`.

Для этого мы используем `security_scopes.scopes`, который содержит `list` со всеми этими scope как `str`.

{* ../../docs_src/security/tutorial005_an_py310.py hl[129:135] *}

## Дерево зависимостей и scope

Давайте еще раз рассмотрим это дерево зависимостей и scope.

Поскольку зависимость `get_current_active_user` имеет подзависимость на `get_current_user`, scope `"me"`, объявленный в `get_current_active_user`, будет включен в список требуемых scope в `security_scopes.scopes`, переданном в `get_current_user`.

Сама *операция пути* также объявляет scope, `"items"`, так что он также будет в списке `security_scopes.scopes`, передаваемом в `get_current_user`.

Вот как выглядит иерархия зависимостей и scope:

* У *операции пути* `read_own_items`:
    * Требуемые scope `["items"]` с зависимостью:
    * `get_current_active_user`:
        * Функция зависимости `get_current_active_user` имеет:
            * Требуемые scope `["me"]` с зависимостью:
            * `get_current_user`:
                * У функции зависимости `get_current_user`:
                    * Нет требуемых scope.
                    * Зависимость, использующая `oauth2_scheme`.
                    * Параметр `security_scopes` типа `SecurityScopes`:
                        * У этого параметра `security_scopes` есть свойство `scopes` со `list`, содержащим все scope, объявленные выше, так что:
                            * `security_scopes.scopes` будет содержать `["me", "items"]` для *операции пути* `read_own_items`.
                            * `security_scopes.scopes` будет содержать `["me"]` для *операции пути* `read_users_me`, потому что он объявлен в зависимости `get_current_active_user`.
                            * `security_scopes.scopes` будет содержать `[]` (ничего) для *операции пути* `read_system_status`, потому что там не объявлено никакое `Security` с `scopes`, и его зависимость `get_current_user` также не объявляет никакие `scopes`.

/// tip | Совет

Самое важное и "магическое" здесь то, что `get_current_user` будет иметь разный список `scopes` для проверки для каждой *операции пути*.

Все зависит от `scopes`, объявленных в каждой *операции пути* и каждой зависимости в дереве зависимостей для данной конкретной *операции пути*.

///

## Подробности о `SecurityScopes`

Вы можете использовать `SecurityScopes` в любой точке и в нескольких местах, он не должен быть на уровне "корневой" зависимости.

Он будет всегда иметь scope безопасности, объявленные в текущих зависимостях `Security` и всех зависимых для **конкретно этой** *операции пути* и **конкретно этого** дерева зависимостей.

Поскольку `SecurityScopes` будут иметь все scope, заявленные зависимыми, вы можете использовать его для проверки того, что токен имеет требуемые scope в центральной функции зависимости, а затем объявлять разные требования к scope в разных *операциях пути*.

Они будут проверяться независимо для каждой *операции пути*.

## Проверьте это

Если вы откроете документацию API, вы можете аутентифицироваться и указать, какие scope вы хотите авторизовать.

<img src="/img/tutorial/security/image11.png">

Если вы не выберете ни один scope, вы будете "аутентифицированы", но при попытке доступа к `/users/me/` или `/users/me/items/` вы получите ошибку, сообщающую, что у вас недостаточно разрешений. Вы все равно сможете получить доступ к `/status/`.

И если вы выберете scope `me`, но не scope `items`, вы сможете получить доступ к `/users/me/`, но не к `/users/me/items/`.

Это именно то, что произойдет с сторонним приложением, которое пытается получить доступ к одной из этих *операций пути* с токеном, предоставленным пользователем, в зависимости от того, сколько разрешений пользователь дал приложению.

## О сторонних интеграциях

В этом примере мы используем OAuth2 "парольный" поток.

Это уместно, когда мы входим в наше собственное приложение, вероятно, с нашим собственным фронтендом.

Потому что мы можем доверять ему получение `username` и `password`, так как мы его контролируем.

Но если вы строите приложение OAuth2, к которому будут подключаться другие (т.е. если вы создаете провайдер аутентификации, эквивалентный Facebook, Google, GitHub и т.д.), вы должны использовать один из других потоков.

Наиболее распространенным является поток implicit.

Наиболее безопасным является поток с кодом, но его сложнее реализовать, так как он требует больше шагов. Поскольку он более сложен, многие провайдеры в конечном итоге предлагают поток implicit.

/// note | Примечание

Часто каждый провайдер аутентификации называет свои потоки по-разному, чтобы сделать это частью своего бренда.

Но в конечном итоге они реализуют тот же стандарт OAuth2.

///

**FastAPI** включает утилиты для всех этих потоков аутентификации OAuth2 в `fastapi.security.oauth2`.

## `Security` в `dependencies` декоратора

Таким же образом, как вы можете определять `list` из `Depends` в параметре `dependencies` декоратора (как объяснено в [Dependencies в декораторах операций пути](../../tutorial/dependencies/dependencies-in-path-operation-decorators.md){.internal-link target=_blank}), вы также можете использовать `Security` с `scopes` там.
