# OAuth2 области

Вы можете использовать OAuth2 области непосредственно с **FastAPI**, они интегрированы для бесшовной работы.

Это позволит вам иметь более детализированную систему разрешений, следуя стандарту OAuth2, интегрированному в ваше приложение OpenAPI (и API-документацию).

OAuth2 с областями — это механизм, используемый многими крупными поставщиками аутентификации, такими как Facebook, Google, GitHub, Microsoft, Twitter и др. Они используют его, чтобы предоставить пользователям и приложениям доступ к определённым разрешениям.

Каждый раз, когда вы "входите через" Facebook, Google, GitHub, Microsoft, Twitter, это приложение использует OAuth2 с областями.

В этом разделе вы узнаете, как управлять аутентификацией и авторизацией с помощью тех же OAuth2 областей в вашем приложении на **FastAPI**.

/// warning | Предупреждение

Это более или менее продвинутый раздел. Если вы только начинаете, вы можете его пропустить.

Вам не обязательно нужны OAuth2 области, и вы можете обрабатывать аутентификацию и авторизацию так, как вам удобно.

Но OAuth2 с областями можно красиво интегрировать в ваш API (с OpenAPI) и в вашу API-документацию.

Тем не менее, вы всё равно соблюдаете эти области или любое другое требование безопасности/авторизации, как вам нужно, в вашем коде.

Во многих случаях, OAuth2 с областями может быть излишен.

Но если вы знаете, что он вам нужен, или вы просто любопытны, продолжайте читать.

///

## OAuth2 области и OpenAPI

Спецификация OAuth2 определяет "области" как список строк, разделённых пробелами.

Содержимое каждой из этих строк может иметь любой формат, но не должно содержать пробелов.

Эти области представляют собой "разрешения".

В OpenAPI (например, в API-документации) вы можете определить "схемы безопасности".

Когда одна из этих схем безопасности использует OAuth2, вы также можете определить и использовать области.

Каждая "область" — это просто строка (без пробелов).

Они обычно используются для определения конкретных разрешений безопасности, например:

* `users:read` или `users:write` — это общие примеры.
* `instagram_basic` используется Facebook / Instagram.
* `https://www.googleapis.com/auth/drive` используется Google.

/// info | Информация

В OAuth2 "область" — это просто строка, которая декларирует необходимое специфическое разрешение.

Неважно, есть ли у неё другие символы, такие как `:`, или если это URL.

Эти детали зависят от реализации.

Для OAuth2 они просто строки.

///

## Глобальный обзор

Во-первых, быстро рассмотрим части, которые изменяются в примерах в основном **Учебнике - Руководстве пользователя** для [OAuth2 с паролем (и хешированием), носитель с JWT токенами](../../tutorial/security/oauth2-jwt.md){.internal-link target=_blank}. Теперь используя OAuth2 области:

{* ../../docs_src/security/tutorial005_an_py310.py hl[5,9,13,47,65,106,108:116,122:125,129:135,140,156] *}

Теперь давайте рассмотрим эти изменения шаг за шагом.

## Схема безопасности OAuth2

Первое изменение заключается в том, что теперь мы объявляем схему безопасности OAuth2 с двумя доступными областями, `me` и `items`.

Параметр `scopes` принимает `dict` с каждой областью в качестве ключа и описанием в качестве значения:

{* ../../docs_src/security/tutorial005_an_py310.py hl[63:66] *}

Поскольку мы теперь объявляем эти области, они будут отображаться в API-документации, когда вы войдете/авторизуетесь.

И вы сможете выбрать, к каким областям вы хотите предоставить доступ: `me` и `items`.

Это тот же механизм, который используется при предоставлении разрешений при входе через Facebook, Google, GitHub и т.д.:

<img src="/img/tutorial/security/image11.png">

## JWT токен с областями

Теперь измените *path operation*, чтобы вернуть запрошенные области.

Мы всё ещё используем тот же `OAuth2PasswordRequestForm`. Он включает собственность `scopes` со `списком` `str`, с каждой областью, полученной в запросе.

И мы возвращаем области как часть JWT токена.

/// danger | Опасность

Для простоты, здесь мы просто добавляем области, полученные напрямую в токен.

Но в вашем приложении, для безопасности, вы должны убедиться, что добавляете только те области, которые пользователь действительно может иметь, или те, которые вы предопределили.

///

{* ../../docs_src/security/tutorial005_an_py310.py hl[156] *}

## Объявление областей в *path operations* и зависимостях

Теперь мы объявляем, что *path operation* для `/users/me/items/` требует область `items`.

Для этого мы импортируем и используем `Security` из `fastapi`.

Вы можете использовать `Security` для объявления зависимостей (так же, как `Depends`), но `Security` также получает параметр `scopes` со списком областей (строк).

В этом случае мы передаем функцию зависимости `get_current_active_user` в `Security` (так же, как мы бы делали с `Depends`).

Но мы также передаем `список` областей, в этом случае только одну область: `items` (их могло бы быть больше).

И функция зависимости `get_current_active_user` также может объявлять подзависимости, не только с помощью `Depends`, но и с помощью `Security`. Объявляя свою подзависимую функцию (`get_current_user`), и дополнительные требования к областям.

В этом случае требуется область `me` (могло бы требоваться более одной области).

/// note | Примечание

Вам не обязательно нужно добавлять разные области в разных местах.

Мы делаем это здесь, чтобы продемонстрировать, как **FastAPI** обрабатывает области, объявленные на разных уровнях.

///

{* ../../docs_src/security/tutorial005_an_py310.py hl[5,140,171] *}

/// info | Технические детали

`Security` на самом деле является подклассом `Depends`, и имеет только один дополнительный параметр, который мы увидим позже.

Но используя `Security` вместо `Depends`, **FastAPI** распознает, что можно объявлять области безопасности, использовать их внутри и документировать API с помощью OpenAPI.

Но когда вы импортируете `Query`, `Path`, `Depends`, `Security` и другие из `fastapi`, это на самом деле функции, которые возвращают специальные классы.

///

## Использование `SecurityScopes`

Теперь обновите зависимость `get_current_user`.

Эта функция используется приведёнными выше зависимостями.

Здесь мы используем ту же схему OAuth2, которую создали ранее, объявляя её как зависимость: `oauth2_scheme`.

Поскольку эта функция зависимости сама по себе не имеет требований к областям, мы можем использовать `Depends` с `oauth2_scheme`, нам не нужно использовать `Security`, когда нам не нужно указывать области безопасности.

Мы также объявляем специальный параметр типа `SecurityScopes`, импортированный из `fastapi.security`.

Этот класс `SecurityScopes` аналогичен `Request` (в `Request` использовался объект запроса напрямую).

{* ../../docs_src/security/tutorial005_an_py310.py hl[9,106] *}

## Используйте `scopes`

Параметр `security_scopes` будет типа `SecurityScopes`.

Он будет иметь свойство `scopes` со списком всех областей, требуемых самой функцией и всеми зависимостями, использующими её как подзависимость. Это значит, все "зависящие"... это может звучать запутанно, ниже объясняется подробнее.

Объект `security_scopes` (класса `SecurityScopes`) также предоставляет атрибут `scope_str` с одной строкой, содержащей эти области, разделённые пробелами (мы его используем).

Мы создаём `HTTPException`, который можем использовать (`raise`) позже в некоторых точках.

В этом исключении мы включаем требуемые области (если они есть) в виде строки, разделённой пробелами (используя `scope_str`). Мы помещаем эту строку, содержащую области, в заголовок `WWW-Authenticate` (это часть спецификации).

{* ../../docs_src/security/tutorial005_an_py310.py hl[106,108:116] *}

## Проверка `username` и формы данных

Мы проверяем, что получили `username`, и извлекаем области.

А затем мы валидируем эти данные с помощью модели Pydantic (отлавливая исключение `ValidationError`), и если у нас есть ошибка чтения JWT токена или валидирования данных с помощью Pydantic, мы возбуждаем созданное ранее `HTTPException`.

Для этого мы обновляем модель Pydantic `TokenData`, добавив новое свойство `scopes`.

Валидируя данные с помощью Pydantic, мы можем убедиться, что у нас есть, например, именно `список` `str` с областями и `str` с `username`.

Вместо, например, `dict`, или чего-то ещё, что могло бы в какой-то момент сломать приложение, создавая риск безопасности.

Мы также проверяем, что у нас есть пользователь с этим именем пользователя, и если нет, мы возбуждаем то же исключение, которое создали ранее.

{* ../../docs_src/security/tutorial005_an_py310.py hl[47,117:128] *}

## Проверка `scopes`

Теперь проверяем, что все области, требуемые этой зависимостью и всеми зависимыми (включая *path operations*), включены в области, предоставленные в полученном токене, в противном случае возбуждаем `HTTPException`.

Для этого используем `security_scopes.scopes`, который содержит `список` со всеми этими областями как `str`.

{* ../../docs_src/security/tutorial005_an_py310.py hl[129:135] *}

## Дерево зависимостей и области

Давайте снова рассмотрим это дерево зависимостей и области.

Поскольку зависимость `get_current_active_user` имеет подзависимость `get_current_user`, область `"me"`, объявленная в `get_current_active_user`, будет включена в `список` требуемых областей в `security_scopes.scopes`, переданный `get_current_user`.

*Path operation* также объявляет область, `"items"`, так что это тоже будет в `списке` `security_scopes.scopes`, переданный `get_current_user`.

Вот как выглядит иерархия зависимостей и областей:

* *Path operation* `read_own_items` имеет:
    * Требуемые области `["items"]` с зависимостью:
    * `get_current_active_user`:
        * Функция зависимости `get_current_active_user` имеет:
            * Требуемые области `["me"]` с зависимостью:
            * `get_current_user`:
                * Функция зависимости `get_current_user` имеет:
                    * Нет требуемых собственной области.
                    * Зависимость, использующую `oauth2_scheme`.
                    * Параметр `security_scopes` типа `SecurityScopes`:
                        * Этот параметр `security_scopes` имеет свойство `scopes` с `списком`, содержащим все выше указанные области, так что:
                            * `security_scopes.scopes` будет содержать `["me", "items"]` для *path operation* `read_own_items`.
                            * `security_scopes.scopes` будет содержать `["me"]` для *path operation* `read_users_me`, потому что она объявлена в зависимости `get_current_active_user`.
                            * `security_scopes.scopes` будет содержать `[]` (ничего) для *path operation* `read_system_status`, потому что она не объявляет никакой `Security` с `scopes`, а её зависимость `get_current_user` также не объявляет никаких `scopes`.

/// tip | Подсказка

Самое важное и "магическое" здесь то, что `get_current_user` будет иметь различный список `scopes` для проверки для каждого *path operation*.

Всё зависит от `scopes`, объявленных в каждом *path operation* и каждой зависимости в дереве зависимостей для этого конкретного *path operation*.

///

## Больше деталей об `SecurityScopes`

Вы можете использовать `SecurityScopes` в любой точке, и в нескольких местах, не обязательно на "корневой" зависимости.

Оно всегда будет иметь области безопасности, объявленные в текущих `Security` зависимостях и все зависимые для **этого конкретного** *path operation* и **этого конкретного** дерева зависимостей.

Поскольку `SecurityScopes` будут иметь все области, объявленные зависимыми, вы можете использовать его для проверки, что токен имеет требуемые области в центральной функции зависимости, а затем объявить различные требования к областям в различных *path operations*.

Они будут проверяться независимо для каждого *path operation*.

## Проверьте это

Если откроете API-документацию, вы можете пройти аутентификацию и указать, какие области хотите авторизовать.

<img src="/img/tutorial/security/image11.png">

Если вы не выберете ни одной области, вы будете "аутентифицированы", но при попытке получить доступ к `/users/me/` или `/users/me/items/` вы получите ошибку, говоря, что у вас недостаточно разрешений. Вы всё ещё сможете получить доступ к `/status/`.

И если вы выберете область `me`, но не `items`, вы сможете получить доступ к `/users/me/`, но не к `/users/me/items/`.

Вот что произойдёт с приложениями третьих сторон, которые пытались бы получить доступ к одной из этих *path operations* с токеном, предоставленным пользователем, в зависимости от того, сколько разрешений пользователь дал приложению.

## О сторонних интеграциях

В этом примере мы используем "парольный" поток OAuth2.

Это уместно, когда мы входим в наше собственное приложение, вероятно, с нашим собственным интерфейсом.

Потому что мы можем доверять ему получение `username` и `password`, так как мы его контролируем.

Но если вы создаёте OAuth2 приложение, к которому будут подключаться другие (то есть, если вы создаёте поставщика аутентификации, эквивалентного Facebook, Google, GitHub и т.д.), вы должны использовать один из других потоков.

Наиболее распространенный — это неявный поток.

Наиболее безопасный — это поток с кодом, но его сложнее реализовать, так как он требует больше шагов. Из-за сложности многие провайдеры в конечном итоге рекомендуют неявный поток.

/// note | Примечание

Часто каждый поставщик аутентификации называет свои потоки по-разному, чтобы сделать это частью их бренда.

Но в конце концов, они реализуют тот же стандарт OAuth2.

///

**FastAPI** включает утилиты для всех этих потоков аутентификации OAuth2 в `fastapi.security.oauth2`.

## `Security` в бедператора `dependencies`

Так же, как вы можете определить `список` `Depends` в параметре `dependencies` там бедператора (как объясняется в [Зависимости в бедператорaх path operation](../../tutorial/dependencies/dependencies-in-path-operation-decorators.md){.internal-link target=_blank}), вы также можете использовать `Security` с `scopes` там.
