# Расширенная конфигурация операций пути

## OpenAPI operationId

/// warning | Предупреждение

Если вы не "эксперт" в OpenAPI, вам, вероятно, это не нужно.

///

Вы можете установить OpenAPI `operationId` для использования в вашей *операции пути* с параметром `operation_id`.

Вам нужно будет убедиться, что он уникален для каждой операции.

{* ../../docs_src/path_operation_advanced_configuration/tutorial001.py hl[6] *}

### Использование имени функции *операции пути* как operationId

Если вы хотите использовать имена функций своих API в качестве `operationId`, вы можете перебрать все из них и переопределить каждый `operation_id` для их *операций пути* используя `APIRoute.name`.

Вы должны сделать это после добавления всех своих *операций пути*.

{* ../../docs_src/path_operation_advanced_configuration/tutorial002.py hl[2, 12:21, 24] *}

/// tip | Совет

Если вы вручную вызываете `app.openapi()`, вам следует обновить `operationId` перед этим.

///

/// warning | Предупреждение

Если вы так делаете, вам нужно убедиться, что каждая из ваших *функций операций пути* имеет уникальное имя.

Даже если они находятся в разных модулях (файлах Python).

///

## Исключение из OpenAPI

Чтобы исключить *операцию пути* из создаваемой схемы OpenAPI (и, следовательно, из систем автоматической документации), используйте параметр `include_in_schema` и установите его в `False`:

{* ../../docs_src/path_operation_advanced_configuration/tutorial003.py hl[6] *}

## Расширенное описание из docstring

Вы можете ограничить строки, используемые из docstring функции *операции пути* для OpenAPI.

Добавление `\f` (экранированный символ "form feed") приводит к тому, что **FastAPI** обрезает вывод, используемый для OpenAPI в этой точке.

Это не будет отображаться в документации, но другие инструменты (такие как Sphinx) смогут использовать остальное.

{* ../../docs_src/path_operation_advanced_configuration/tutorial004.py hl[19:29] *}

## Дополнительные ответы

Вы, вероятно, уже видели, как объявлять `response_model` и `status_code` для *операции пути*.

Это определяет метаданные о основном ответе *операции пути*.

Вы также можете объявить дополнительные ответы с их моделями, статусами кодов и т. д.

Здесь есть целая глава в документации об этом, вы можете прочитать ее в разделе [Дополнительные ответы в OpenAPI](additional-responses.md){.internal-link target=_blank}.

## OpenAPI Extra

Когда вы объявляете *операцию пути* в своем приложении, **FastAPI** автоматически генерирует соответствующие метаданные об этой *операции пути* для включения в схему OpenAPI.

/// note | Технические детали

В спецификации OpenAPI это называется <a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#operation-object" class="external-link" target="_blank">Operation Object</a>.

///

Он содержит всю информацию о *операции пути* и используется для генерации автоматической документации.

Он включает `tags`, `parameters`, `requestBody`, `responses` и т. д.

Эта OpenAPI схема, специфичная для *операции пути*, обычно генерируется автоматически **FastAPI**, но вы также можете расширить ее.

/// tip | Совет

Это низкоуровневая точка расширения.

Если вам нужно только объявить дополнительные ответы, более удобный способ сделать это — с [Дополнительные ответы в OpenAPI](additional-responses.md){.internal-link target=_blank}.

///

Вы можете расширить схему OpenAPI для *операции пути* с помощью параметра `openapi_extra`.

### Расширения OpenAPI

Этот `openapi_extra` может быть полезен, например, для объявления [OpenAPI Extensions](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#specificationExtensions):

{* ../../docs_src/path_operation_advanced_configuration/tutorial005.py hl[6] *}

Если вы откроете автоматическую документацию API, ваше расширение будет отображено внизу конкретной *операции пути*.

<img src="/img/tutorial/path-operation-advanced-configuration/image01.png">

И если вы посмотрите на результат OpenAPI (по адресу `/openapi.json` в вашем API), вы увидите свое расширение как часть конкретной *операции пути* тоже:

```JSON hl_lines="22"
{
    "openapi": "3.1.0",
    "info": {
        "title": "FastAPI",
        "version": "0.1.0"
    },
    "paths": {
        "/items/": {
            "get": {
                "summary": "Read Items",
                "operationId": "read_items_items__get",
                "responses": {
                    "200": {
                        "description": "Successful Response",
                        "content": {
                            "application/json": {
                                "schema": {}
                            }
                        }
                    }
                },
                "x-aperture-labs-portal": "blue"
            }
        }
    }
}
```

### Индивидуальная OpenAPI схема *операции пути*

Словарь в `openapi_extra` будет глубоко объединен с автоматически сгенерированной схемой OpenAPI для *операции пути*.

Таким образом, вы сможете добавить дополнительные данные к автоматически сгенерированной схеме.

Например, вы могли бы решить считать и проверять запрос с помощью вашего собственного кода, не используя автоматические функции FastAPI с Pydantic, но при этом вы могли бы захотеть определить запрос в схеме OpenAPI.

Вы могли бы сделать это с помощью `openapi_extra`:

{* ../../docs_src/path_operation_advanced_configuration/tutorial006.py hl[19:36, 39:40] *}

В этом примере мы не объявляли модель Pydantic. Фактически, тело запроса даже не <abbr title="преобразовано из какого-то простого формата, как байты, в объекты Python">проанализировано</abbr> как JSON, оно читается напрямую как `bytes`, и функция `magic_data_reader()` будет отвечать за его парсинг каким-то образом.

Тем не менее, мы можем объявить ожидаемую схему для тела запроса.

### Индивидуальный тип содержимого OpenAPI

Используя эту же хитрость, вы могли бы использовать модель Pydantic для определения JSON Schema, которое затем включается в пользовательскую секцию OpenAPI схемы для *операции пути*.

И вы могли бы сделать это, даже если тип данных в запросе не является JSON.

Например, в этом приложении мы не используем интегрированную функциональность FastAPI для извлечения JSON Schema из моделей Pydantic, ни автоматической валидации для JSON. Фактически, мы объявляем тип содержимого запроса как YAML, а не JSON:

//// tab | Pydantic v2

{* ../../docs_src/path_operation_advanced_configuration/tutorial007.py hl[17:22, 24] *}

////

//// tab | Pydantic v1

{* ../../docs_src/path_operation_advanced_configuration/tutorial007_pv1.py hl[17:22, 24] *}

////

/// info | Информация

В версии Pydantic 1 метод для получения JSON Schema для модели назывался `Item.schema()`, в версии Pydantic 2 этот метод называется `Item.model_json_schema()`.

///

Тем не менее, хотя мы и не используем стандартную интегрированную функциональность, мы все равно используем модель Pydantic для ручной генерации JSON Schema для данных, которые мы хотим получить в формате YAML.

Затем мы используем запрос напрямую и извлекаем тело как `bytes`. Это означает, что FastAPI даже не пытается парсить полезную нагрузку запроса как JSON.

А в нашем коде мы парсим содержимое YAML напрямую и затем снова используем ту же модель Pydantic для валидации содержимого YAML:

//// tab | Pydantic v2

{* ../../docs_src/path_operation_advanced_configuration/tutorial007.py hl[26:33] *}

////

//// tab | Pydantic v1

{* ../../docs_src/path_operation_advanced_configuration/tutorial007_pv1.py hl[26:33] *}

////

/// info | Информация

В версии Pydantic 1 метод для парсинга и валидации объекта назывался `Item.parse_obj()`, в версии Pydantic 2 этот метод называется `Item.model_validate()`.

///

/// tip | Совет

Здесь мы используем ту же самую модель Pydantic.

Но таким же образом, мы могли бы валидировать ее и другим способом.

///
