# Пользовательские классы Request и APIRoute

В некоторых случаях вам может понадобиться переопределить логику, используемую в классах `Request` и `APIRoute`.

В частности, это может быть хорошей альтернативой логике в middleware (Промежуточный слой).

Например, если вы хотите прочитать или изменить тело запроса до того, как оно будет обработано вашим приложением.

/// danger

Это "продвинутая" функция.

Если вы только начинаете работать с **FastAPI**, вы можете пропустить этот раздел.

///

## Сценарии использования

Некоторые сценарии использования включают:

* Конвертация тел запросов, не являющихся JSON, в JSON (например, <a href="https://msgpack.org/index.html" class="external-link" target="_blank">`msgpack`</a>).
* Разжатие тел запросов, сжатых методом gzip.
* Автоматическое логирование всех тел запросов.

## Обработка пользовательских кодировок тела запроса

Давайте посмотрим, как использовать пользовательский подкласс `Request` для разжатия gzip-запросов.

И подкласс `APIRoute`, чтобы использовать этот пользовательский класс запроса.

### Создание пользовательского класса `GzipRequest`

/// tip | Совет

Это учебный пример, чтобы показать как это работает. Если вам нужна поддержка gzip, вы можете использовать предоставленный [`GzipMiddleware`](../advanced/middleware.md#gzipmiddleware){.internal-link target=_blank}.

///

Сначала мы создадим класс `GzipRequest`, который переопределит метод `Request.body()`, чтобы разжать тело запроса, если присутствует соответствующий заголовок.

Если в заголовке нет `gzip`, он не будет пытаться разжать тело запроса.

Таким образом, один и тот же класс маршрута может обрабатывать как gzip-сжатые, так и несжатые запросы.

{* ../../docs_src/custom_request_and_route/tutorial001.py hl[8:15] *}

### Создание пользовательского класса `GzipRoute`

Затем мы создаем пользовательский подкласс `fastapi.routing.APIRoute`, который будет использовать `GzipRequest`.

На этот раз он переопределит метод `APIRoute.get_route_handler()`.

Этот метод возвращает функцию. И эта функция принимает запрос и возвращает ответ.

Здесь мы используем его для создания `GzipRequest` из исходного запроса.

{* ../../docs_src/custom_request_and_route/tutorial001.py hl[18:26] *}

/// note | Технические детали

`Request` имеет атрибут `request.scope`, который является просто Python-словарем, содержащим метаданные, относящиеся к запросу.

`Request` также имеет `request.receive`, это функция для "получения" тела запроса.

Словарь `scope` и функция `receive` являются частью спецификации ASGI.

И именно эти две вещи, `scope` и `receive`, нужны для создания нового экземпляра `Request`.

Чтобы узнать больше о `Request`, ознакомьтесь с <a href="https://www.starlette.io/requests/" class="external-link" target="_blank">документацией Starlette о запросах</a>.

///

Единственное, что функция, возвращаемая `GzipRequest.get_route_handler`, делает иначе, это преобразует `Request` в `GzipRequest`.

Таким образом, наш `GzipRequest` позаботится о разжатии данных (если это необходимо) перед передачей их нашим *операциям пути*.

После этого вся логика обработки такая же.

Но благодаря изменениям в `GzipRequest.body`, тело запроса будет автоматически разжиматься, когда **FastAPI** нужно будет его загрузить.

## Доступ к телу запроса в обработчике исключений

/// tip | Подсказка

Чтобы решить эту же проблему, вероятно, гораздо проще использовать `body` в пользовательском обработчике для `RequestValidationError` ([Обработка ошибок](../tutorial/handling-errors.md#use-the-requestvalidationerror-body){.internal-link target=_blank}).

Но этот пример по-прежнему актуален и показывает, как взаимодействовать с внутренними компонентами.

///

Мы также можем использовать этот же подход, чтобы получить доступ к телу запроса в обработчике исключений.

Все, что нам нужно сделать, — это обработать запрос внутри блока `try`/`except`:

{* ../../docs_src/custom_request_and_route/tutorial002.py hl[13,15] *}

Если возникает исключение, экземпляр `Request` все равно будет доступен, поэтому мы можем прочитать и использовать тело запроса при обработке ошибки:

{* ../../docs_src/custom_request_and_route/tutorial002.py hl[16:18] *}

## Пользовательский класс `APIRoute` в роутере

Вы также можете установить параметр `route_class` для `APIRouter`:

{* ../../docs_src/custom_request_and_route/tutorial003.py hl[26] *}

В этом примере *операции путей* под `router` будут использовать пользовательский класс `TimedRoute`, и в ответе будет добавлен дополнительный HTTP-заголовок `X-Response-Time` с временем, затраченным на генерацию ответа:

{* ../../docs_src/custom_request_and_route/tutorial003.py hl[13:20] *}
